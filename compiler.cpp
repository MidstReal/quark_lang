#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
using namespace std;

namespace Color {
    const string RED = "\033[31m";
    const string GREEN = "\033[32m";
    const string YELLOW = "\033[33m";
    const string RESET = "\033[0m";
}

const int comnum = 100;
const int argnum = 10;

ifstream in;
ofstream out;

bool hex_used = false;
bool hex_routines_generated = false;

string commands[comnum] = { "end", "var", "POINT", "call", "jump", "term", "if", "include", "untill", "putpixel", "print:", "cls" };
string arg[argnum];
string current_line;

void chknocom();
void chkcom();


void mov(string farg0, string farg1);
void sub(string farg0, string farg1);
void add(string farg0, string farg1);
void int_(string farg0);
void jump(string farg0);
void call(string farg0);
void anytext(string farg0);

int main(int argc, char* argv[])
{
    if (argc < 2) {
        cout << Color::RED << "ERROR: " << Color::RESET << "Input file isn't specified!" << endl;
        cout << Color::YELLOW << "EXAMPLE: " << Color::RESET << "./compile input.qkl -o output.asm" << endl;
        return 1;
    }


    string inputFile = argv[1];
    string outputFile = argv[2];

    if (argc >= 4 && string(argv[2]) == "-o") {
        outputFile = argv[3];
    } else if (argc >= 3) {
        outputFile = argv[2];
    }

    in.open(inputFile);
    out.open(outputFile);

    string line;

    cout << Color::YELLOW << "compiling..." << endl;
    if (in.is_open() && out.is_open())
    {
        anytext("; code generated by the Quark language compiler v0.3.0");
        while (getline(in, line))
        {
            if (line.empty()) continue;
            istringstream iss(line);
            current_line = line;

                iss >> arg[0];

                if (arg[0] == "asm:") {
                    string restOfLine;
                    getline(iss, restOfLine);
                    if (!restOfLine.empty()) {
                        if (restOfLine[0] == ' ') restOfLine.erase(0, 1);
                        out << restOfLine << endl;
                    }
                    continue;
                }

                iss >> arg[1] >> arg[2] >> arg[3] >> arg[4] >> arg[5] >> arg[6] >> arg[7] >> arg[8] >> arg[9];

            chkcom();
            if(arg[0] == ";") continue;
            else {
                bool fnd = false;
                for (int i = 0; i<comnum; i++){
                    if(!commands[i].empty() && arg[0] == commands[i]){
                        fnd = true;
                        break;
                    }

                }
                if (!fnd) chknocom();

            }
        }

    } else {
        cout << Color::RED << "ERROR: " << Color::RESET << "Error opening files" << endl;
        if (!in.is_open()) {
            cout << Color::RED << "Cannot open input file: " << inputFile << Color::RESET << endl;
        }
        if (!out.is_open()) {
            cout << Color::RED << "Cannot create output file: " << outputFile << Color::RESET << endl;
        }
        return 1;
    }
    in.close();
    out.close();

}

string parse_string_literal(const string& str) {
    if (str.length() >= 2 && str[0] == '"' && str[str.length()-1] == '"') {
        return str.substr(1, str.length()-2);
    }
    return str;
}

void chknocom(){
    string type;

    if(arg[3] == ":BYTE") {
        type = "byte ";
    } else if(arg[3] == ":WORD") {
        type = "word ";
    } else if(arg[3] == ":DWORD") {
       type = "dword ";
    } else type = "";


    if(arg[1] == "=") mov(type + arg[0], arg[2]);
    else if(arg[1] == "+="){
        mov("al", arg[0]);
        add("al", arg[2]);
        mov(arg[0], "al");
    }
    else if(arg[1] == "-=") {
        mov("al", arg[0]);
        sub("al", arg[2]);
        mov(arg[0], "al");
    }
    else if(arg[1] == "++") {
        anytext("inc " + type + arg[0]);
    }
    else if(arg[1] == "--") {
        anytext("dec " + type + arg[0]);
    }
    else if(arg[1] == "<tochar>"){
        mov("al", arg[0]);
        add("al", "'0'");
        mov(arg[0], "al");
    }
    else if(arg[1] == "<tonum>"){
        mov("al", arg[0]);
        sub("al", "'0'");
        mov(arg[0], "al");
    }

}
void chkcom(){
        if(arg[0] == "print:"){
        if (arg[1] == "char"){
            mov("ah", "0x0e");
            mov("al", arg[2]);
            int_("0x10");
        }
        else if(arg[1] == "num"){
            mov("al", arg[2]);
            add("al", "'0'");
            mov("ah", "0x0e");
            int_("0x10");
        }
        else if(arg[1] == "str"){
            string prefix = "print: str";
            size_t pos = current_line.find(prefix);
            if (pos != string::npos) {
                string rest = current_line.substr(pos + prefix.length());
                rest.erase(0, rest.find_first_not_of(" \t"));
                rest.erase(rest.find_last_not_of(" \t") + 1);

                string text = parse_string_literal(rest);

                for (size_t i = 0; i < text.length(); ++i) {
                    char c = text[i];
                    if (c == '\\' && i + 1 < text.length()) {
                        char next = text[i + 1];
                        if (next == 'n') {
                            mov("al", "0x0d");
                            int_("0x10");
                            mov("al", "0x0a");
                            int_("0x10");
                            i++;
                            continue;
                        }
                    }
                    mov("ah", "0x0e");
                    string char_str = "'";
                    char_str += c;
                    char_str += "'";
                    mov("al", char_str);
                    int_("0x10");
                }
            }
        }
        else if(arg[1] == "hex"){
            hex_used = true;
            string addr = arg[2];
            if(addr.length() > 2 && addr[0] == '[' && addr[addr.length()-1] == ']') {
                string inner = addr.substr(1, addr.length()-2);
                size_t colon = inner.find(':');
                if(colon != string::npos) {
                    string seg = inner.substr(0, colon);
                    string off = inner.substr(colon+1);
                    
                    anytext("push ds");
                    mov("ax", seg);
                    mov("ds", "ax");
                    mov("si", off);
                    anytext("lodsb");
                    anytext("pop ds");
                    anytext("call hex_print_routine");
                }
            }
        }
    }
    else if(arg[0] == "readch"){
        mov("ah", "0x00");
        int_("0x16");
        if (arg[1] != ":NULL"){
            mov(arg[1], "ah");
        }
        if (arg[2] != ":NULL"){
            mov(arg[2], "al");
        }
    }
    else if(arg[0] == "putpixel"){
        mov("ah", "0x0c");
        mov("al", "0x0f");
        mov("cx", arg[1]);
        mov("dx", arg[2]);
        int_("0x10");
    }
    else if(arg[0] == "cls"){
        if(arg[1] == "textmode"){
            mov("ah", "0x00");
            mov("al", "0x03");
            int_("0x10");
        }
        else if(arg[1] == "vgamode"){
            mov("ax", "0x0013");
            int_("0x10");
        }

    }
    else if(arg[0] == "var"){
        string type;

        if(arg[2] == "1=") {
            type = "db";
        } else if(arg[2] == "2=") {
            type = "dw";
        } else if(arg[2] == "4=") {
            type = "dd";
        } else if(arg[2] == "8=") {
            type = "dq";
        } else type = "db";
        size_t eq = current_line.find('=');
        if (eq != string::npos) {
            string val = current_line.substr(eq + 1);
            val.erase(0, val.find_first_not_of(" \t"));
            anytext(arg[1] + " " + type + " " + val);
        } else {
            anytext(arg[1] + " " + type + " 0");
        }
    }
    else if (arg[0] == "if") {
        string type;

        if (arg[6] == ":BYTE"){
            type = "byte ";
        } else if(arg[6] == ":WORD"){
            type = "word ";
        } else if(arg[6] == ":DWORD"){
            type = "dword ";
        }

        mov("al", arg[1]);
        anytext("cmp "+ type +"al, " + arg[3]);
        if (arg[2] == "!=") out << "jne " << arg[5] << endl;
        else if (arg[2] == "==") out << "je " << arg[5] << endl;
        else if (arg[2] == "<=")  out << "jbe " << arg[5] << endl;
        else if (arg[2] == ">=")  out << "jae " << arg[5] << endl;
        else if (arg[2] == "<")  out << "jb " << arg[5] << endl;
        else if (arg[2] == ">")  out << "ja " << arg[5] << endl;
    }
    // for var < num point
    else if (arg[0] == "untill"){
        string type;

        if (arg[5] == ":BYTE"){
            type = "byte ";
        } else if(arg[5] == ":WORD"){
            type = "word ";
        } else if(arg[5] == ":DWORD"){
            type = "dword ";
        }

        mov("al", arg[1]);
        anytext("cmp "+ type +"al, " + arg[3]);

        if (arg[2] == "!=") out << "je " << arg[4] << endl;
        else if (arg[2] == "==") out << "jne " << arg[4] << endl;
        else if (arg[2] == "<=")  out << "jbe " << arg[4] << endl;
        else if (arg[2] == ">=")  out << "jae " << arg[4] << endl;
        else if (arg[2] == "<")  out << "jb " << arg[4] << endl;
        else if (arg[2] == ">")  out << "ja " << arg[4] << endl;


    }
    // disk: command drive cylinder head sector segment offset
    else if(arg[0] == "disk:"){
        if(arg[1] == "read_chs"){
            mov("ah", "0x02");
            mov("al", "0x01");
            mov("ch", arg[3]);
            mov("cl", arg[5]);
            mov("dh", arg[4]);
            mov("dl", arg[2]);
            mov("bx", arg[6]);
            mov("es", "bx");
            mov("bx", arg[7]);
            int_("0x13");
        }else if(arg[1] == "write_chs"){

            mov("ah", "0x03");
            mov("al", "0x01");
            mov("ch", arg[3]);
            mov("cl", arg[5]);
            mov("dh", arg[4]);
            mov("dl", arg[2]);
            mov("bx", arg[6]);
            mov("es", "bx");
            mov("bx", arg[7]);
            int_("0x13");
        }
        else if(arg[1] == "init"){
            mov("ax", "0");
            mov("ds", "ax");
            mov("es", "ax");
            mov("ss", "ax");
        }

    }


    else if (hex_used && !hex_routines_generated && arg[0] == "printhexcode") {
        out << "hex_print_routine:" << endl;
        out << "push ax" << endl;
        out << "push bx" << endl;
        out << "push cx" << endl;
        out << "push dx" << endl;
        out << "mov ah, al" << endl;
        out << "shr al, 4" << endl;
        out << "call hex_digit" << endl;
        out << "mov al, ah" << endl;
        out << "and al, 0x0F" << endl;
        out << "call hex_digit" << endl;
        out << "pop dx" << endl;
        out << "pop cx" << endl;
        out << "pop bx" << endl;
        out << "pop ax" << endl;
        out << "ret" << endl << endl;
        
        out << "hex_digit:" << endl;
        out << "cmp al, 10" << endl;
        out << "jl .digit" << endl;
        out << "add al, 'A' - 10" << endl;
        out << "jmp .print" << endl;
        out << ".digit:" << endl;
        out << "add al, '0'" << endl;
        out << ".print:" << endl;
        out << "push ax" << endl;
        out << "mov ah, 0x0e" << endl;
        out << "int 0x10" << endl;
        out << "pop ax" << endl;
        out << "ret" << endl;
        
        hex_routines_generated = true;
    }

    else if(arg[0] == "bootsector"){
        anytext("times 510-($-$$) db 0");
        anytext("db 0x55, 0xaa");
    }

    else if(arg[0] == "POINT") anytext(arg[1]);
    else if(arg[0] == "term") anytext("ret");
    else if(arg[0] == "include") anytext("%INCLUDE " + arg[1]);
    else if(arg[0] == "jump") jump(arg[1]);
    else if(arg[0] == "call") call(arg[1]);
    else if(arg[0] == "reboot") int_("0x19");


    // else cout << Color::YELLOW << "NOTE: " << Color::RESET << Color::GREEN << arg[0] << Color::RESET << " - unknown command" << endl;

}

void mov(string farg0, string farg1){
    out << "mov " << farg0 << ", " << farg1 << endl;
}
void sub(string farg0, string farg1){
    out << "sub " << farg0 << ", " << farg1 << endl;
}
void add(string farg0, string farg1){
    out << "add " << farg0 << ", " << farg1 << endl;
}
void int_(string farg0){
    out << "int " << farg0 << endl;
}
void jump(string farg0){
    out << "jmp " << farg0 << endl;
}
void call(string farg0){
    out << "call " << farg0 << endl;
}
void anytext(string farg0){
    out << farg0 << endl;
}
